/*
 * Decompiled with CFR 0.152.
 */
package org.hibernate.engine.jdbc.internal;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.sql.Statement;
import org.hibernate.AssertionFailure;
import org.hibernate.ScrollMode;
import org.hibernate.boot.spi.SessionFactoryOptions;
import org.hibernate.engine.jdbc.internal.JdbcCoordinatorImpl;
import org.hibernate.engine.jdbc.spi.JdbcServices;
import org.hibernate.engine.jdbc.spi.SqlExceptionHelper;
import org.hibernate.engine.jdbc.spi.StatementPreparer;
import org.hibernate.resource.jdbc.spi.JdbcObserver;
import org.hibernate.resource.jdbc.spi.LogicalConnectionImplementor;

class StatementPreparerImpl
implements StatementPreparer {
    private final JdbcCoordinatorImpl jdbcCoordinator;
    private final JdbcServices jdbcServices;

    StatementPreparerImpl(JdbcCoordinatorImpl jdbcCoordinator, JdbcServices jdbcServices) {
        this.jdbcCoordinator = jdbcCoordinator;
        this.jdbcServices = jdbcServices;
    }

    protected final SessionFactoryOptions settings() {
        return this.jdbcCoordinator.sessionFactory().getSessionFactoryOptions();
    }

    protected final Connection connection() {
        return this.logicalConnection().getPhysicalConnection();
    }

    protected final LogicalConnectionImplementor logicalConnection() {
        return this.jdbcCoordinator.getLogicalConnection();
    }

    protected final SqlExceptionHelper sqlExceptionHelper() {
        return this.jdbcServices.getSqlExceptionHelper();
    }

    @Override
    public Statement createStatement() {
        try {
            Statement statement = this.connection().createStatement();
            this.jdbcCoordinator.getResourceRegistry().register(statement, true);
            return statement;
        }
        catch (SQLException e) {
            throw this.sqlExceptionHelper().convert(e, "could not create statement");
        }
    }

    @Override
    public PreparedStatement prepareStatement(String sql) {
        return this.buildPreparedStatementPreparationTemplate(sql, false).prepareStatement();
    }

    @Override
    public PreparedStatement prepareStatement(String sql, boolean isCallable) {
        this.jdbcCoordinator.executeBatch();
        return this.buildPreparedStatementPreparationTemplate(sql, isCallable).prepareStatement();
    }

    private StatementPreparationTemplate buildPreparedStatementPreparationTemplate(String sql, final boolean isCallable) {
        return new StatementPreparationTemplate(sql){

            @Override
            protected PreparedStatement doPrepare() throws SQLException {
                return isCallable ? StatementPreparerImpl.this.connection().prepareCall(this.sql) : StatementPreparerImpl.this.connection().prepareStatement(this.sql);
            }
        };
    }

    private void checkAutoGeneratedKeysSupportEnabled() {
        if (!this.settings().isGetGeneratedKeysEnabled()) {
            throw new AssertionFailure("getGeneratedKeys() support is not enabled");
        }
    }

    @Override
    public PreparedStatement prepareStatement(String sql, final int autoGeneratedKeys) {
        if (autoGeneratedKeys == 1) {
            this.checkAutoGeneratedKeysSupportEnabled();
        }
        this.jdbcCoordinator.executeBatch();
        return new StatementPreparationTemplate(sql){

            @Override
            public PreparedStatement doPrepare() throws SQLException {
                return StatementPreparerImpl.this.connection().prepareStatement(this.sql, autoGeneratedKeys);
            }
        }.prepareStatement();
    }

    @Override
    public PreparedStatement prepareStatement(String sql, final String[] columnNames) {
        this.checkAutoGeneratedKeysSupportEnabled();
        this.jdbcCoordinator.executeBatch();
        return new StatementPreparationTemplate(sql){

            @Override
            public PreparedStatement doPrepare() throws SQLException {
                return StatementPreparerImpl.this.connection().prepareStatement(this.sql, columnNames);
            }
        }.prepareStatement();
    }

    @Override
    public PreparedStatement prepareQueryStatement(String sql, final boolean isCallable, final ScrollMode scrollMode) {
        if (scrollMode != null && !scrollMode.equals((Object)ScrollMode.FORWARD_ONLY)) {
            if (!this.settings().isScrollableResultSetsEnabled()) {
                throw new AssertionFailure("scrollable result sets are not enabled");
            }
            PreparedStatement ps = new QueryStatementPreparationTemplate(sql){

                @Override
                public PreparedStatement doPrepare() throws SQLException {
                    return isCallable ? StatementPreparerImpl.this.connection().prepareCall(this.sql, scrollMode.toResultSetType(), 1007) : StatementPreparerImpl.this.connection().prepareStatement(this.sql, scrollMode.toResultSetType(), 1007);
                }
            }.prepareStatement();
            this.jdbcCoordinator.registerLastQuery(ps);
            return ps;
        }
        PreparedStatement ps = new QueryStatementPreparationTemplate(sql){

            @Override
            public PreparedStatement doPrepare() throws SQLException {
                return isCallable ? StatementPreparerImpl.this.connection().prepareCall(this.sql) : StatementPreparerImpl.this.connection().prepareStatement(this.sql);
            }
        }.prepareStatement();
        this.jdbcCoordinator.registerLastQuery(ps);
        return ps;
    }

    private void setStatementFetchSize(PreparedStatement statement) throws SQLException {
        if (this.settings().getJdbcFetchSize() != null) {
            statement.setFetchSize(this.settings().getJdbcFetchSize());
        }
    }

    private abstract class QueryStatementPreparationTemplate
    extends StatementPreparationTemplate {
        protected QueryStatementPreparationTemplate(String sql) {
            super(sql);
        }

        @Override
        public void postProcess(PreparedStatement preparedStatement) throws SQLException {
            super.postProcess(preparedStatement);
            StatementPreparerImpl.this.setStatementFetchSize(preparedStatement);
        }
    }

    private abstract class StatementPreparationTemplate {
        protected final String sql;

        protected StatementPreparationTemplate(String incomingSql) {
            String inspectedSql = StatementPreparerImpl.this.jdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getStatementInspector().inspect(incomingSql);
            this.sql = inspectedSql == null ? incomingSql : inspectedSql;
        }

        public PreparedStatement prepareStatement() {
            try {
                PreparedStatement preparedStatement;
                StatementPreparerImpl.this.jdbcServices.getSqlStatementLogger().logStatement(this.sql);
                JdbcObserver observer = StatementPreparerImpl.this.jdbcCoordinator.getJdbcSessionOwner().getJdbcSessionContext().getObserver();
                try {
                    observer.jdbcPrepareStatementStart();
                    preparedStatement = this.doPrepare();
                    this.setStatementTimeout(preparedStatement);
                }
                finally {
                    observer.jdbcPrepareStatementEnd();
                }
                this.postProcess(preparedStatement);
                return preparedStatement;
            }
            catch (SQLException e) {
                throw StatementPreparerImpl.this.sqlExceptionHelper().convert(e, "could not prepare statement", this.sql);
            }
        }

        protected abstract PreparedStatement doPrepare() throws SQLException;

        public void postProcess(PreparedStatement preparedStatement) throws SQLException {
            StatementPreparerImpl.this.jdbcCoordinator.getResourceRegistry().register(preparedStatement, true);
        }

        private void setStatementTimeout(PreparedStatement preparedStatement) throws SQLException {
            int remainingTransactionTimeOutPeriod = StatementPreparerImpl.this.jdbcCoordinator.determineRemainingTransactionTimeOutPeriod();
            if (remainingTransactionTimeOutPeriod > 0) {
                preparedStatement.setQueryTimeout(remainingTransactionTimeOutPeriod);
            }
        }
    }
}

