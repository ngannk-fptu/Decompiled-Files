/*
 * Decompiled with CFR 0.152.
 */
package clj_time;

import clj_time.format$fn__19161;
import clj_time.format$fn__19174;
import clj_time.format$fn__19268;
import clj_time.format$fn__19271;
import clj_time.format$fn__19283;
import clj_time.format$fn__19285;
import clj_time.format$fn__19287;
import clj_time.format$formatter;
import clj_time.format$formatter_local;
import clj_time.format$loading__6789__auto____19159;
import clj_time.format$parse;
import clj_time.format$parse_local;
import clj_time.format$parse_local_date;
import clj_time.format$parse_local_time;
import clj_time.format$show_formatters;
import clj_time.format$to_map;
import clj_time.format$unparse;
import clj_time.format$unparse_local;
import clj_time.format$unparse_local_date;
import clj_time.format$unparse_local_time;
import clj_time.format$with_chronology;
import clj_time.format$with_default_year;
import clj_time.format$with_locale;
import clj_time.format$with_pivot_year;
import clj_time.format$with_zone;
import clojure.lang.AFn;
import clojure.lang.AReference;
import clojure.lang.Compiler;
import clojure.lang.IFn;
import clojure.lang.IObj;
import clojure.lang.IPersistentMap;
import clojure.lang.ISeq;
import clojure.lang.Keyword;
import clojure.lang.LockingTransaction;
import clojure.lang.Namespace;
import clojure.lang.PersistentArrayMap;
import clojure.lang.PersistentHashSet;
import clojure.lang.PersistentList;
import clojure.lang.RT;
import clojure.lang.Symbol;
import clojure.lang.Tuple;
import clojure.lang.Var;
import java.util.Arrays;
import java.util.Locale;
import org.joda.time.format.ISODateTimeFormat;

public class format__init {
    public static final Var const__0;
    public static final AFn const__1;
    public static final Keyword const__2;
    public static final AFn const__3;
    public static final AFn const__4;
    public static final Var const__5;
    public static final AFn const__12;
    public static final Var const__13;
    public static final AFn const__19;
    public static final Var const__20;
    public static final AFn const__24;
    public static final Var const__25;
    public static final AFn const__28;
    public static final Var const__29;
    public static final AFn const__32;
    public static final Var const__33;
    public static final AFn const__36;
    public static final Var const__37;
    public static final AFn const__40;
    public static final Var const__41;
    public static final AFn const__44;
    public static final AFn const__46;
    public static final Var const__47;
    public static final Var const__48;
    public static final Keyword const__49;
    public static final Keyword const__50;
    public static final Keyword const__51;
    public static final Keyword const__52;
    public static final Keyword const__53;
    public static final Keyword const__54;
    public static final Keyword const__55;
    public static final Keyword const__56;
    public static final Keyword const__57;
    public static final Keyword const__58;
    public static final Keyword const__59;
    public static final Keyword const__60;
    public static final Keyword const__61;
    public static final Keyword const__62;
    public static final Keyword const__63;
    public static final Keyword const__64;
    public static final Keyword const__65;
    public static final Keyword const__66;
    public static final Keyword const__67;
    public static final Keyword const__68;
    public static final Keyword const__69;
    public static final Keyword const__70;
    public static final Keyword const__71;
    public static final Keyword const__72;
    public static final Keyword const__73;
    public static final Keyword const__74;
    public static final Keyword const__75;
    public static final Keyword const__76;
    public static final Keyword const__77;
    public static final Keyword const__78;
    public static final Keyword const__79;
    public static final Keyword const__80;
    public static final Keyword const__81;
    public static final Keyword const__82;
    public static final Keyword const__83;
    public static final Keyword const__84;
    public static final Keyword const__85;
    public static final Keyword const__86;
    public static final Keyword const__87;
    public static final Keyword const__88;
    public static final Keyword const__89;
    public static final Keyword const__90;
    public static final Keyword const__91;
    public static final Keyword const__92;
    public static final Keyword const__93;
    public static final Keyword const__94;
    public static final Keyword const__95;
    public static final Keyword const__96;
    public static final Keyword const__97;
    public static final Keyword const__98;
    public static final Keyword const__99;
    public static final Keyword const__100;
    public static final Keyword const__101;
    public static final Var const__102;
    public static final AFn const__105;
    public static final AFn const__106;
    public static final Var const__107;
    public static final AFn const__109;
    public static final Var const__110;
    public static final Var const__111;
    public static final Var const__112;
    public static final Var const__113;
    public static final Object const__114;
    public static final AFn const__117;
    public static final Var const__118;
    public static final AFn const__122;
    public static final Var const__123;
    public static final AFn const__127;
    public static final Var const__128;
    public static final AFn const__132;
    public static final Var const__133;
    public static final AFn const__136;
    public static final Var const__137;
    public static final AFn const__140;
    public static final Var const__141;
    public static final AFn const__144;
    public static final Var const__145;
    public static final AFn const__148;
    public static final Var const__149;
    public static final AFn const__152;
    public static final Object const__153;
    public static final Var const__154;
    public static final Var const__155;
    public static final Var const__156;
    public static final Var const__157;
    public static final ISeq const__158;
    public static final Var const__159;
    public static final Var const__160;
    public static final AFn const__164;
    public static final Keyword const__165;
    public static final AFn const__166;
    public static final Keyword const__167;
    public static final Keyword const__168;
    public static final Keyword const__169;
    public static final AFn const__170;
    public static final Keyword const__171;
    public static final Var const__172;
    public static final Var const__173;
    public static final Var const__174;
    public static final AFn const__175;
    public static final AFn const__176;
    public static final Keyword const__177;
    public static final Var const__178;
    public static final AFn const__179;
    public static final Var const__180;
    public static final AFn const__183;
    public static final Var const__184;
    public static final Object const__185;
    public static final Object const__186;

    public static void load() {
        Object v3;
        Object object = ((IFn)const__0.getRawRoot()).invoke(const__1);
        IPersistentMap iPersistentMap = ((AReference)Namespace.find((Symbol)const__1)).resetMeta((IPersistentMap)((Object)const__3));
        Object object2 = ((IFn)new format$loading__6789__auto____19159()).invoke();
        if (((Symbol)const__1).equals(const__4)) {
            v3 = null;
        } else {
            LockingTransaction.runInTransaction(new format$fn__19161());
            v3 = null;
        }
        Var var = const__5;
        Var var2 = var;
        var.setMeta((IPersistentMap)((Object)const__12));
        Var var3 = const__13;
        var3.setMeta((IPersistentMap)((Object)const__19));
        Var var4 = var3;
        var3.bindRoot(new format$formatter());
        Var var5 = const__20;
        var5.setMeta((IPersistentMap)((Object)const__24));
        Var var6 = var5;
        var5.bindRoot(new format$formatter_local());
        Var var7 = const__25;
        var7.setMeta((IPersistentMap)((Object)const__28));
        Var var8 = var7;
        var7.bindRoot(new format$with_chronology());
        Var var9 = const__29;
        var9.setMeta((IPersistentMap)((Object)const__32));
        Var var10 = var9;
        var9.bindRoot(new format$with_locale());
        Var var11 = const__33;
        var11.setMeta((IPersistentMap)((Object)const__36));
        Var var12 = var11;
        var11.bindRoot(new format$with_pivot_year());
        Var var13 = const__37;
        var13.setMeta((IPersistentMap)((Object)const__40));
        Var var14 = var13;
        var13.bindRoot(new format$with_zone());
        Var var15 = const__41;
        var15.setMeta((IPersistentMap)((Object)const__44));
        Var var16 = var15;
        var15.bindRoot(new format$with_default_year());
        Var var17 = const__5;
        var17.setMeta((IPersistentMap)((Object)const__46));
        Var var18 = var17;
        var17.bindRoot(((IFn)const__47.getRawRoot()).invoke(PersistentArrayMap.EMPTY, ((IFn)const__48.getRawRoot()).invoke(new format$fn__19174(), RT.mapUniqueKeys(const__49, ISODateTimeFormat.dateElementParser(), const__50, ISODateTimeFormat.hourMinute(), const__51, ISODateTimeFormat.tTime(), const__52, ISODateTimeFormat.basicOrdinalDate(), const__53, ISODateTimeFormat.date(), const__54, ISODateTimeFormat.hour(), const__55, ISODateTimeFormat.timeNoMillis(), const__56, ISODateTimeFormat.weekyearWeekDay(), const__57, ISODateTimeFormat.weekDateTime(), const__58, ISODateTimeFormat.dateHourMinuteSecondFraction(), const__59, ISODateTimeFormat.basicDateTime(), const__60, ISODateTimeFormat.dateTime(), const__61, ISODateTimeFormat.basicTimeNoMillis(), const__62, ISODateTimeFormat.dateParser(), const__63, ISODateTimeFormat.basicWeekDate(), const__64, ISODateTimeFormat.basicTTimeNoMillis(), const__65, ISODateTimeFormat.localTimeParser(), const__66, ISODateTimeFormat.dateTimeNoMillis(), const__67, ISODateTimeFormat.yearMonthDay(), const__68, ISODateTimeFormat.dateOptionalTimeParser(), const__69, ((IFn)const__29.getRawRoot()).invoke(((IFn)const__13.getRawRoot()).invoke("EEE, dd MMM yyyy HH:mm:ss Z"), Locale.US), const__70, ISODateTimeFormat.dateHourMinuteSecondMillis(), const__71, ISODateTimeFormat.basicOrdinalDateTime(), const__72, ISODateTimeFormat.ordinalDate(), const__73, ISODateTimeFormat.hourMinuteSecondFraction(), const__74, ISODateTimeFormat.dateHourMinute(), const__75, ISODateTimeFormat.time(), const__76, ISODateTimeFormat.basicWeekDateTime(), const__77, ISODateTimeFormat.weekyear(), const__78, ISODateTimeFormat.basicTime(), const__79, ISODateTimeFormat.hourMinuteSecond(), const__80, ISODateTimeFormat.ordinalDateTime(), const__81, ISODateTimeFormat.ordinalDateTimeNoMillis(), const__82, ISODateTimeFormat.hourMinuteSecondMillis(), const__83, ISODateTimeFormat.timeParser(), const__84, ISODateTimeFormat.dateTimeParser(), const__85, ISODateTimeFormat.year(), const__86, ISODateTimeFormat.tTimeNoMillis(), const__87, ISODateTimeFormat.basicWeekDateTimeNoMillis(), const__88, ISODateTimeFormat.basicDate(), const__89, ISODateTimeFormat.weekyearWeek(), const__90, ISODateTimeFormat.localDateParser(), const__91, ISODateTimeFormat.basicOrdinalDateTimeNoMillis(), const__92, ISODateTimeFormat.yearMonth(), const__93, ISODateTimeFormat.localDateOptionalTimeParser(), const__94, ISODateTimeFormat.weekDate(), const__95, ISODateTimeFormat.dateHour(), const__96, ISODateTimeFormat.timeElementParser(), const__97, ISODateTimeFormat.dateHourMinuteSecond(), const__98, ISODateTimeFormat.weekDateTimeNoMillis(), const__99, ISODateTimeFormat.basicDateTimeNoMillis(), const__100, ((IFn)const__13.getRawRoot()).invoke("yyyy-MM-dd HH:mm:ss"), const__101, ISODateTimeFormat.basicTTime()))));
        Var var19 = const__102;
        var19.setMeta((IPersistentMap)((Object)const__105));
        Var var20 = var19;
        var19.bindRoot(const__106);
        Var var21 = const__107;
        var21.setMeta((IPersistentMap)((Object)const__109));
        Var var22 = var21;
        var21.bindRoot(((IFn)const__110.getRawRoot()).invoke(((IFn)const__111.getRawRoot()).invoke(((IFn)const__112.getRawRoot()).invoke(const__5.getRawRoot())), const__102.getRawRoot()));
        Var var23 = const__113;
        var23.setMeta((IPersistentMap)((Object)const__117));
        Var var24 = var23;
        var23.bindRoot(new format$parse());
        Var var25 = const__118;
        var25.setMeta((IPersistentMap)((Object)const__122));
        Var var26 = var25;
        var25.bindRoot(new format$parse_local());
        Var var27 = const__123;
        var27.setMeta((IPersistentMap)((Object)const__127));
        Var var28 = var27;
        var27.bindRoot(new format$parse_local_date());
        Var var29 = const__128;
        var29.setMeta((IPersistentMap)((Object)const__132));
        Var var30 = var29;
        var29.bindRoot(new format$parse_local_time());
        Var var31 = const__133;
        var31.setMeta((IPersistentMap)((Object)const__136));
        Var var32 = var31;
        var31.bindRoot(new format$unparse());
        Var var33 = const__137;
        var33.setMeta((IPersistentMap)((Object)const__140));
        Var var34 = var33;
        var33.bindRoot(new format$unparse_local());
        Var var35 = const__141;
        var35.setMeta((IPersistentMap)((Object)const__144));
        Var var36 = var35;
        var35.bindRoot(new format$unparse_local_date());
        Var var37 = const__145;
        var37.setMeta((IPersistentMap)((Object)const__148));
        Var var38 = var37;
        var37.bindRoot(new format$unparse_local_time());
        Var var39 = const__149;
        var39.setMeta((IPersistentMap)((Object)const__152));
        Var var40 = var39;
        var39.bindRoot(new format$show_formatters());
        Object object3 = ((IFn)new format$fn__19268()).invoke();
        Object object4 = const__153;
        Object object5 = ((IFn)const__154.getRawRoot()).invoke(const__155, const__156.getRawRoot(), const__2, null);
        Object object6 = ((IFn)const__157).invoke(const__155, const__158);
        Object object7 = ((IFn)const__159.getRawRoot()).invoke(const__155, const__160.getRawRoot(), ((IFn)const__156.getRawRoot()).invoke(const__164, const__165, const__166, const__167, const__155, const__168, const__170, const__171, RT.mapUniqueKeys(((IFn)const__172.getRawRoot()).invoke(const__173.get(), ((IFn)const__174.getRawRoot()).invoke(const__175, ((IFn)const__160.getRawRoot()).invoke(const__176, RT.mapUniqueKeys(const__177, const__155)))), new format$fn__19271())));
        Object object8 = ((IFn)const__178.getRawRoot()).invoke(const__155.getRawRoot());
        AFn aFn = const__179;
        Var var41 = const__180;
        var41.setMeta((IPersistentMap)((Object)const__183));
        Var var42 = var41;
        var41.bindRoot(new format$to_map());
        Object object9 = ((IFn)const__184.getRawRoot()).invoke(const__114, const__155.getRawRoot(), RT.mapUniqueKeys(const__169, new format$fn__19283()));
        Object object10 = ((IFn)const__184.getRawRoot()).invoke(const__185, const__155.getRawRoot(), RT.mapUniqueKeys(const__169, new format$fn__19285()));
        Object object11 = ((IFn)const__184.getRawRoot()).invoke(const__186, const__155.getRawRoot(), RT.mapUniqueKeys(const__169, new format$fn__19287()));
    }

    public static void __init0() {
        const__0 = RT.var("clojure.core", "in-ns");
        const__1 = (AFn)((Object)((IObj)Symbol.intern(null, "clj-time.format")).withMeta(RT.map(RT.keyword(null, "doc"), "Utilities for parsing and unparsing DateTimes as Strings.\n\n   Parsing and printing are controlled by formatters. You can either use one\n   of the built in ISO 8601 and a single RFC 822 formatters or define your own, e.g.:\n\n     (def built-in-formatter (formatters :basic-date-time))\n     (def custom-formatter (formatter \"yyyyMMdd\"))\n\n   To see a list of available built-in formatters and an example of a date-time\n   printed in their format:\n\n    (show-formatters)\n\n   Once you have a formatter, parsing and printing are straightforward:\n\n     => (parse custom-formatter \"20100311\")\n     #<DateTime 2010-03-11T00:00:00.000Z>\n\n     => (unparse custom-formatter (date-time 2010 10 3))\n     \"20101003\"\n\n   By default the parse function always returns a DateTime instance with a UTC\n   time zone, and the unparse function always represents a given DateTime\n   instance in UTC. A formatter can be modified to different timezones, locales,\n   etc with the functions with-zone, with-locale, with-chronology,\n   with-default-year and with-pivot-year.")));
        const__2 = RT.keyword(null, "doc");
        const__3 = (AFn)((Object)RT.map(RT.keyword(null, "doc"), "Utilities for parsing and unparsing DateTimes as Strings.\n\n   Parsing and printing are controlled by formatters. You can either use one\n   of the built in ISO 8601 and a single RFC 822 formatters or define your own, e.g.:\n\n     (def built-in-formatter (formatters :basic-date-time))\n     (def custom-formatter (formatter \"yyyyMMdd\"))\n\n   To see a list of available built-in formatters and an example of a date-time\n   printed in their format:\n\n    (show-formatters)\n\n   Once you have a formatter, parsing and printing are straightforward:\n\n     => (parse custom-formatter \"20100311\")\n     #<DateTime 2010-03-11T00:00:00.000Z>\n\n     => (unparse custom-formatter (date-time 2010 10 3))\n     \"20101003\"\n\n   By default the parse function always returns a DateTime instance with a UTC\n   time zone, and the unparse function always represents a given DateTime\n   instance in UTC. A formatter can be modified to different timezones, locales,\n   etc with the functions with-zone, with-locale, with-chronology,\n   with-default-year and with-pivot-year."));
        const__4 = Symbol.intern(null, "clojure.core");
        const__5 = RT.var("clj-time.format", "formatters");
        const__12 = (AFn)((Object)RT.map(RT.keyword(null, "declared"), Boolean.TRUE, RT.keyword(null, "line"), 38, RT.keyword(null, "column"), 1, RT.keyword(null, "file"), "clj_time/format.clj"));
        const__13 = RT.var("clj-time.format", "formatter");
        const__19 = (AFn)((Object)RT.map(RT.keyword(null, "tag"), RT.classForName("org.joda.time.format.DateTimeFormatter"), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(Tuple.create(Symbol.intern(null, "fmts")), Tuple.create(Symbol.intern(null, "fmts"), ((IObj)Symbol.intern(null, "dtz")).withMeta(RT.map(RT.keyword(null, "tag"), Symbol.intern(null, "DateTimeZone")))), Tuple.create(((IObj)Symbol.intern(null, "dtz")).withMeta(RT.map(RT.keyword(null, "tag"), Symbol.intern(null, "DateTimeZone"))), Symbol.intern(null, "fmts"), Symbol.intern(null, "&"), Symbol.intern(null, "more")))), RT.keyword(null, "doc"), "Returns a custom formatter for the given date-time pattern or keyword.", RT.keyword(null, "line"), 41, RT.keyword(null, "column"), 1, RT.keyword(null, "file"), "clj_time/format.clj"));
        const__20 = RT.var("clj-time.format", "formatter-local");
        const__24 = (AFn)((Object)RT.map(RT.keyword(null, "tag"), RT.classForName("org.joda.time.format.DateTimeFormat"), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(Tuple.create(((IObj)Symbol.intern(null, "fmt")).withMeta(RT.map(RT.keyword(null, "tag"), Symbol.intern(null, "String")))))), RT.keyword(null, "doc"), "Returns a custom formatter with no time zone info.", RT.keyword(null, "line"), 59, RT.keyword(null, "column"), 1, RT.keyword(null, "file"), "clj_time/format.clj"));
        const__25 = RT.var("clj-time.format", "with-chronology");
        const__28 = (AFn)((Object)RT.map(RT.keyword(null, "tag"), RT.classForName("org.joda.time.format.DateTimeFormatter"), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(Tuple.create(((IObj)Symbol.intern(null, "f")).withMeta(RT.map(RT.keyword(null, "tag"), Symbol.intern(null, "DateTimeFormatter"))), ((IObj)Symbol.intern(null, "c")).withMeta(RT.map(RT.keyword(null, "tag"), Symbol.intern(null, "Chronology")))))), RT.keyword(null, "doc"), "Return a copy of a formatter that uses the given Chronology.", RT.keyword(null, "line"), 64, RT.keyword(null, "column"), 1, RT.keyword(null, "file"), "clj_time/format.clj"));
        const__29 = RT.var("clj-time.format", "with-locale");
        const__32 = (AFn)((Object)RT.map(RT.keyword(null, "tag"), RT.classForName("org.joda.time.format.DateTimeFormatter"), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(Tuple.create(((IObj)Symbol.intern(null, "f")).withMeta(RT.map(RT.keyword(null, "tag"), Symbol.intern(null, "DateTimeFormatter"))), ((IObj)Symbol.intern(null, "l")).withMeta(RT.map(RT.keyword(null, "tag"), Symbol.intern(null, "Locale")))))), RT.keyword(null, "doc"), "Return a copy of a formatter that uses the given Locale.", RT.keyword(null, "line"), 69, RT.keyword(null, "column"), 1, RT.keyword(null, "file"), "clj_time/format.clj"));
        const__33 = RT.var("clj-time.format", "with-pivot-year");
        const__36 = (AFn)((Object)RT.map(RT.keyword(null, "tag"), RT.classForName("org.joda.time.format.DateTimeFormatter"), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(Tuple.create(((IObj)Symbol.intern(null, "f")).withMeta(RT.map(RT.keyword(null, "tag"), Symbol.intern(null, "DateTimeFormatter"))), ((IObj)Symbol.intern(null, "pivot-year")).withMeta(RT.map(RT.keyword(null, "tag"), Symbol.intern(null, "Long")))))), RT.keyword(null, "doc"), "Return a copy of a formatter that uses the given pivot year.", RT.keyword(null, "line"), 74, RT.keyword(null, "column"), 1, RT.keyword(null, "file"), "clj_time/format.clj"));
        const__37 = RT.var("clj-time.format", "with-zone");
        const__40 = (AFn)((Object)RT.map(RT.keyword(null, "tag"), RT.classForName("org.joda.time.format.DateTimeFormatter"), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(Tuple.create(((IObj)Symbol.intern(null, "f")).withMeta(RT.map(RT.keyword(null, "tag"), Symbol.intern(null, "DateTimeFormatter"))), ((IObj)Symbol.intern(null, "dtz")).withMeta(RT.map(RT.keyword(null, "tag"), Symbol.intern(null, "DateTimeZone")))))), RT.keyword(null, "doc"), "Return a copy of a formatter that uses the given DateTimeZone.", RT.keyword(null, "line"), 79, RT.keyword(null, "column"), 1, RT.keyword(null, "file"), "clj_time/format.clj"));
        const__41 = RT.var("clj-time.format", "with-default-year");
        const__44 = (AFn)((Object)RT.map(RT.keyword(null, "tag"), RT.classForName("org.joda.time.format.DateTimeFormatter"), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(Tuple.create(((IObj)Symbol.intern(null, "f")).withMeta(RT.map(RT.keyword(null, "tag"), Symbol.intern(null, "DateTimeFormatter"))), ((IObj)Symbol.intern(null, "default-year")).withMeta(RT.map(RT.keyword(null, "tag"), Symbol.intern(null, "Integer")))))), RT.keyword(null, "doc"), "Return a copy of a formatter that uses the given default year.", RT.keyword(null, "line"), 84, RT.keyword(null, "column"), 1, RT.keyword(null, "file"), "clj_time/format.clj"));
        const__46 = (AFn)((Object)RT.map(RT.keyword(null, "doc"), "Map of ISO 8601 and a single RFC 822 formatters that can be used for parsing and, in most\n             cases, printing.", RT.keyword(null, "line"), 89, RT.keyword(null, "column"), 1, RT.keyword(null, "file"), "clj_time/format.clj"));
        const__47 = RT.var("clojure.core", "into");
        const__48 = RT.var("clojure.core", "map");
        const__49 = RT.keyword(null, "date-element-parser");
        const__50 = RT.keyword(null, "hour-minute");
        const__51 = RT.keyword(null, "t-time");
        const__52 = RT.keyword(null, "basic-ordinal-date");
        const__53 = RT.keyword(null, "date");
        const__54 = RT.keyword(null, "hour");
        const__55 = RT.keyword(null, "time-no-ms");
        const__56 = RT.keyword(null, "weekyear-week-day");
        const__57 = RT.keyword(null, "week-date-time");
        const__58 = RT.keyword(null, "date-hour-minute-second-fraction");
        const__59 = RT.keyword(null, "basic-date-time");
        const__60 = RT.keyword(null, "date-time");
        const__61 = RT.keyword(null, "basic-time-no-ms");
        const__62 = RT.keyword(null, "date-parser");
        const__63 = RT.keyword(null, "basic-week-date");
        const__64 = RT.keyword(null, "basic-t-time-no-ms");
        const__65 = RT.keyword(null, "local-time");
        const__66 = RT.keyword(null, "date-time-no-ms");
        const__67 = RT.keyword(null, "year-month-day");
        const__68 = RT.keyword(null, "date-opt-time");
        const__69 = RT.keyword(null, "rfc822");
        const__70 = RT.keyword(null, "date-hour-minute-second-ms");
        const__71 = RT.keyword(null, "basic-ordinal-date-time");
        const__72 = RT.keyword(null, "ordinal-date");
        const__73 = RT.keyword(null, "hour-minute-second-fraction");
        const__74 = RT.keyword(null, "date-hour-minute");
        const__75 = RT.keyword(null, "time");
        const__76 = RT.keyword(null, "basic-week-date-time");
        const__77 = RT.keyword(null, "weekyear");
        const__78 = RT.keyword(null, "basic-time");
        const__79 = RT.keyword(null, "hour-minute-second");
        const__80 = RT.keyword(null, "ordinal-date-time");
        const__81 = RT.keyword(null, "ordinal-date-time-no-ms");
        const__82 = RT.keyword(null, "hour-minute-second-ms");
        const__83 = RT.keyword(null, "time-parser");
        const__84 = RT.keyword(null, "date-time-parser");
        const__85 = RT.keyword(null, "year");
        const__86 = RT.keyword(null, "t-time-no-ms");
        const__87 = RT.keyword(null, "basic-week-date-time-no-ms");
        const__88 = RT.keyword(null, "basic-date");
        const__89 = RT.keyword(null, "weekyear-week");
        const__90 = RT.keyword(null, "local-date");
        const__91 = RT.keyword(null, "basic-ordinal-date-time-no-ms");
        const__92 = RT.keyword(null, "year-month");
        const__93 = RT.keyword(null, "local-date-opt-time");
        const__94 = RT.keyword(null, "week-date");
        const__95 = RT.keyword(null, "date-hour");
        const__96 = RT.keyword(null, "time-element-parser");
        const__97 = RT.keyword(null, "date-hour-minute-second");
        const__98 = RT.keyword(null, "week-date-time-no-ms");
        const__99 = RT.keyword(null, "basic-date-time-no-ms");
    }

    public static void __init1() {
        const__100 = RT.keyword(null, "mysql");
        const__101 = RT.keyword(null, "basic-t-time");
        const__102 = RT.var("clj-time.format", "parsers");
        const__105 = (AFn)((Object)RT.map(RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "line"), 148, RT.keyword(null, "column"), 1, RT.keyword(null, "file"), "clj_time/format.clj"));
        const__106 = PersistentHashSet.create(RT.keyword(null, "date-element-parser"), RT.keyword(null, "date-parser"), RT.keyword(null, "local-time"), RT.keyword(null, "date-opt-time"), RT.keyword(null, "time-parser"), RT.keyword(null, "date-time-parser"), RT.keyword(null, "local-date"), RT.keyword(null, "local-date-opt-time"), RT.keyword(null, "time-element-parser"));
        const__107 = RT.var("clj-time.format", "printers");
        const__109 = (AFn)((Object)RT.map(RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "line"), 153, RT.keyword(null, "column"), 1, RT.keyword(null, "file"), "clj_time/format.clj"));
        const__110 = RT.var("clojure.set", "difference");
        const__111 = RT.var("clojure.core", "set");
        const__112 = RT.var("clojure.core", "keys");
        const__113 = RT.var("clj-time.format", "parse");
        const__114 = RT.classForName("org.joda.time.DateTime");
        const__117 = (AFn)((Object)RT.map(RT.keyword(null, "tag"), RT.classForName("org.joda.time.DateTime"), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(Tuple.create(((IObj)Symbol.intern(null, "fmt")).withMeta(RT.map(RT.keyword(null, "tag"), Symbol.intern(null, "DateTimeFormatter"))), ((IObj)Symbol.intern(null, "s")).withMeta(RT.map(RT.keyword(null, "tag"), Symbol.intern(null, "String")))), Tuple.create(((IObj)Symbol.intern(null, "s")).withMeta(RT.map(RT.keyword(null, "tag"), Symbol.intern(null, "String")))))), RT.keyword(null, "doc"), "Returns a DateTime instance in the UTC time zone obtained by parsing the\n   given string according to the given formatter.", RT.keyword(null, "line"), 156, RT.keyword(null, "column"), 1, RT.keyword(null, "file"), "clj_time/format.clj"));
        const__118 = RT.var("clj-time.format", "parse-local");
        const__122 = (AFn)((Object)RT.map(RT.keyword(null, "tag"), RT.classForName("org.joda.time.LocalDateTime"), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(Tuple.create(((IObj)Symbol.intern(null, "fmt")).withMeta(RT.map(RT.keyword(null, "tag"), Symbol.intern(null, "DateTimeFormatter"))), ((IObj)Symbol.intern(null, "s")).withMeta(RT.map(RT.keyword(null, "tag"), Symbol.intern(null, "String")))), Tuple.create(((IObj)Symbol.intern(null, "s")).withMeta(RT.map(RT.keyword(null, "tag"), Symbol.intern(null, "String")))))), RT.keyword(null, "doc"), "Returns a LocalDateTime instance obtained by parsing the\n   given string according to the given formatter.", RT.keyword(null, "line"), 167, RT.keyword(null, "column"), 1, RT.keyword(null, "file"), "clj_time/format.clj"));
        const__123 = RT.var("clj-time.format", "parse-local-date");
        const__127 = (AFn)((Object)RT.map(RT.keyword(null, "tag"), RT.classForName("org.joda.time.LocalDate"), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(Tuple.create(((IObj)Symbol.intern(null, "fmt")).withMeta(RT.map(RT.keyword(null, "tag"), Symbol.intern(null, "DateTimeFormatter"))), ((IObj)Symbol.intern(null, "s")).withMeta(RT.map(RT.keyword(null, "tag"), Symbol.intern(null, "String")))), Tuple.create(((IObj)Symbol.intern(null, "s")).withMeta(RT.map(RT.keyword(null, "tag"), Symbol.intern(null, "String")))))), RT.keyword(null, "doc"), "Returns a LocalDate instance obtained by parsing the\n   given string according to the given formatter.", RT.keyword(null, "line"), 178, RT.keyword(null, "column"), 1, RT.keyword(null, "file"), "clj_time/format.clj"));
        const__128 = RT.var("clj-time.format", "parse-local-time");
        const__132 = (AFn)((Object)RT.map(RT.keyword(null, "tag"), RT.classForName("org.joda.time.LocalTime"), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(Tuple.create(((IObj)Symbol.intern(null, "fmt")).withMeta(RT.map(RT.keyword(null, "tag"), Symbol.intern(null, "DateTimeFormatter"))), ((IObj)Symbol.intern(null, "s")).withMeta(RT.map(RT.keyword(null, "tag"), Symbol.intern(null, "String")))), Tuple.create(((IObj)Symbol.intern(null, "s")).withMeta(RT.map(RT.keyword(null, "tag"), Symbol.intern(null, "String")))))), RT.keyword(null, "doc"), "Returns a LocalTime instance obtained by parsing the\n  given string according to the given formatter.", RT.keyword(null, "line"), 189, RT.keyword(null, "column"), 1, RT.keyword(null, "file"), "clj_time/format.clj"));
        const__133 = RT.var("clj-time.format", "unparse");
        const__136 = (AFn)((Object)RT.map(RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(Tuple.create(((IObj)Symbol.intern(null, "fmt")).withMeta(RT.map(RT.keyword(null, "tag"), Symbol.intern(null, "DateTimeFormatter"))), ((IObj)Symbol.intern(null, "dt")).withMeta(RT.map(RT.keyword(null, "tag"), Symbol.intern(null, "DateTime")))))), RT.keyword(null, "doc"), "Returns a string representing the given DateTime instance in UTC and in the\n  form determined by the given formatter.", RT.keyword(null, "line"), 200, RT.keyword(null, "column"), 1, RT.keyword(null, "file"), "clj_time/format.clj"));
        const__137 = RT.var("clj-time.format", "unparse-local");
        const__140 = (AFn)((Object)RT.map(RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(Tuple.create(((IObj)Symbol.intern(null, "fmt")).withMeta(RT.map(RT.keyword(null, "tag"), Symbol.intern(null, "DateTimeFormatter"))), ((IObj)Symbol.intern(null, "dt")).withMeta(RT.map(RT.keyword(null, "tag"), Symbol.intern(null, "LocalDateTime")))))), RT.keyword(null, "doc"), "Returns a string representing the given LocalDateTime instance in the\n  form determined by the given formatter.", RT.keyword(null, "line"), 206, RT.keyword(null, "column"), 1, RT.keyword(null, "file"), "clj_time/format.clj"));
        const__141 = RT.var("clj-time.format", "unparse-local-date");
        const__144 = (AFn)((Object)RT.map(RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(Tuple.create(((IObj)Symbol.intern(null, "fmt")).withMeta(RT.map(RT.keyword(null, "tag"), Symbol.intern(null, "DateTimeFormatter"))), ((IObj)Symbol.intern(null, "ld")).withMeta(RT.map(RT.keyword(null, "tag"), Symbol.intern(null, "LocalDate")))))), RT.keyword(null, "doc"), "Returns a string representing the given LocalDate instance in the form\n  determined by the given formatter.", RT.keyword(null, "line"), 212, RT.keyword(null, "column"), 1, RT.keyword(null, "file"), "clj_time/format.clj"));
        const__145 = RT.var("clj-time.format", "unparse-local-time");
        const__148 = (AFn)((Object)RT.map(RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(Tuple.create(((IObj)Symbol.intern(null, "fmt")).withMeta(RT.map(RT.keyword(null, "tag"), Symbol.intern(null, "DateTimeFormatter"))), ((IObj)Symbol.intern(null, "lt")).withMeta(RT.map(RT.keyword(null, "tag"), Symbol.intern(null, "LocalTime")))))), RT.keyword(null, "doc"), "Returns a string representing the given LocalTime instance in the form\n  determined by the given formatter.", RT.keyword(null, "line"), 218, RT.keyword(null, "column"), 1, RT.keyword(null, "file"), "clj_time/format.clj"));
        const__149 = RT.var("clj-time.format", "show-formatters");
        const__152 = (AFn)((Object)RT.map(RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(Tuple.create(), Tuple.create(((IObj)Symbol.intern(null, "dt")).withMeta(RT.map(RT.keyword(null, "tag"), Symbol.intern(null, "DateTime")))))), RT.keyword(null, "doc"), "Shows how a given DateTime, or by default the current time, would be\n  formatted with each of the available printing formatters.", RT.keyword(null, "line"), 225, RT.keyword(null, "column"), 1, RT.keyword(null, "file"), "clj_time/format.clj"));
        const__153 = RT.classForName("clj_time.format.Mappable");
        const__154 = RT.var("clojure.core", "alter-meta!");
        const__155 = RT.var("clj-time.format", "Mappable");
        const__156 = RT.var("clojure.core", "assoc");
        const__157 = RT.var("clojure.core", "assert-same-protocol");
        const__158 = (ISeq)((Object)PersistentList.create(Arrays.asList(((IObj)Symbol.intern(null, "instant->map")).withMeta(RT.map(RT.keyword(null, "doc"), "Returns a map representation of the given instant.\n                          It will contain the following keys: :years, :months,\n                          :days, :hours, :minutes and :seconds.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(Tuple.create(Symbol.intern(null, "instant")))))))));
        const__159 = RT.var("clojure.core", "alter-var-root");
        const__160 = RT.var("clojure.core", "merge");
        const__164 = (AFn)((Object)RT.map(RT.keyword(null, "on"), Symbol.intern(null, "clj_time.format.Mappable"), RT.keyword(null, "on-interface"), RT.classForName("clj_time.format.Mappable")));
        const__165 = RT.keyword(null, "sigs");
        const__166 = (AFn)((Object)RT.map(RT.keyword(null, "instant->map"), RT.map(RT.keyword(null, "tag"), null, RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "instant->map")).withMeta(RT.map(RT.keyword(null, "doc"), "Returns a map representation of the given instant.\n                          It will contain the following keys: :years, :months,\n                          :days, :hours, :minutes and :seconds.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(Tuple.create(Symbol.intern(null, "instant")))))), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(Tuple.create(Symbol.intern(null, "instant")))), RT.keyword(null, "doc"), "Returns a map representation of the given instant.\n                          It will contain the following keys: :years, :months,\n                          :days, :hours, :minutes and :seconds.")));
        const__167 = RT.keyword(null, "var");
        const__168 = RT.keyword(null, "method-map");
        const__169 = RT.keyword(null, "instant->map");
        const__170 = (AFn)((Object)RT.map(RT.keyword(null, "instant->map"), RT.keyword(null, "instant->map")));
        const__171 = RT.keyword(null, "method-builders");
        const__172 = RT.var("clojure.core", "intern");
        const__173 = RT.var("clojure.core", "*ns*");
        const__174 = RT.var("clojure.core", "with-meta");
        const__175 = (AFn)((Object)((IObj)Symbol.intern(null, "instant->map")).withMeta(RT.map(RT.keyword(null, "doc"), "Returns a map representation of the given instant.\n                          It will contain the following keys: :years, :months,\n                          :days, :hours, :minutes and :seconds.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(Tuple.create(Symbol.intern(null, "instant")))))));
        const__176 = (AFn)((Object)RT.map(RT.keyword(null, "tag"), null, RT.keyword(null, "name"), ((IObj)Symbol.intern(null, "instant->map")).withMeta(RT.map(RT.keyword(null, "doc"), "Returns a map representation of the given instant.\n                          It will contain the following keys: :years, :months,\n                          :days, :hours, :minutes and :seconds.", RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(Tuple.create(Symbol.intern(null, "instant")))))), RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(Tuple.create(Symbol.intern(null, "instant")))), RT.keyword(null, "doc"), "Returns a map representation of the given instant.\n                          It will contain the following keys: :years, :months,\n                          :days, :hours, :minutes and :seconds."));
        const__177 = RT.keyword(null, "protocol");
        const__178 = RT.var("clojure.core", "-reset-methods");
        const__179 = Symbol.intern(null, "Mappable");
        const__180 = RT.var("clj-time.format", "to-map");
        const__183 = (AFn)((Object)RT.map(RT.keyword(null, "private"), Boolean.TRUE, RT.keyword(null, "arglists"), PersistentList.create(Arrays.asList(Tuple.create(Symbol.intern(null, "years"), Symbol.intern(null, "months"), Symbol.intern(null, "days"), Symbol.intern(null, "hours"), Symbol.intern(null, "minutes"), Symbol.intern(null, "seconds")))), RT.keyword(null, "line"), 239, RT.keyword(null, "column"), 1, RT.keyword(null, "file"), "clj_time/format.clj"));
        const__184 = RT.var("clojure.core", "extend");
        const__185 = RT.classForName("org.joda.time.Period");
        const__186 = RT.classForName("org.joda.time.Interval");
    }

    static {
        format__init.__init0();
        format__init.__init1();
        Compiler.pushNSandLoader(RT.classForName("clj_time.format__init").getClassLoader());
        try {
            format__init.load();
        }
        catch (Throwable throwable2) {
            Var.popThreadBindings();
            throw throwable2;
        }
        Var.popThreadBindings();
    }
}

