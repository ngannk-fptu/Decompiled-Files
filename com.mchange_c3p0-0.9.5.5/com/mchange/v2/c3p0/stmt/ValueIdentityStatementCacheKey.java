/*
 * Decompiled with CFR 0.152.
 * 
 * Could not load the following classes:
 *  com.mchange.v2.coalesce.CoalesceChecker
 *  com.mchange.v2.coalesce.Coalescer
 *  com.mchange.v2.coalesce.CoalescerFactory
 */
package com.mchange.v2.c3p0.stmt;

import com.mchange.v2.c3p0.stmt.StatementCacheKey;
import com.mchange.v2.coalesce.CoalesceChecker;
import com.mchange.v2.coalesce.Coalescer;
import com.mchange.v2.coalesce.CoalescerFactory;
import java.lang.reflect.Method;
import java.sql.Connection;

final class ValueIdentityStatementCacheKey
extends StatementCacheKey {
    static final Coalescer keyCoalescer;
    static ValueIdentityStatementCacheKey spare;
    int cached_hash;

    ValueIdentityStatementCacheKey() {
    }

    /*
     * Enabled force condition propagation
     * Lifted jumps to return sites
     */
    static StatementCacheKey _find(Connection pcon, Method stmtProducingMethod, Object[] args) {
        Integer resultSetHoldability;
        Integer autogeneratedKeys;
        String[] columnNames;
        int[] columnIndexes;
        int result_set_concurrency;
        int result_set_type;
        String stmtText = (String)args[0];
        boolean is_callable = stmtProducingMethod.getName().equals("prepareCall");
        if (args.length == 1) {
            result_set_type = 1003;
            result_set_concurrency = 1007;
            columnIndexes = null;
            columnNames = null;
            autogeneratedKeys = null;
            resultSetHoldability = null;
        } else if (args.length == 2) {
            Class<?>[] argTypes = stmtProducingMethod.getParameterTypes();
            if (argTypes[1].isArray()) {
                Class<?> baseType = argTypes[1].getComponentType();
                if (baseType == Integer.TYPE) {
                    result_set_type = 1003;
                    result_set_concurrency = 1007;
                    columnIndexes = (int[])args[1];
                    columnNames = null;
                    autogeneratedKeys = null;
                    resultSetHoldability = null;
                } else {
                    if (baseType != String.class) throw new IllegalArgumentException("c3p0 probably needs to be updated for some new JDBC spec! As of JDBC3, we expect two arg statement producing methods where the second arg is either an int, int array, or String array.");
                    result_set_type = 1003;
                    result_set_concurrency = 1007;
                    columnIndexes = null;
                    columnNames = (String[])args[1];
                    autogeneratedKeys = null;
                    resultSetHoldability = null;
                }
            } else {
                result_set_type = 1003;
                result_set_concurrency = 1007;
                columnIndexes = null;
                columnNames = null;
                autogeneratedKeys = (Integer)args[1];
                resultSetHoldability = null;
            }
        } else if (args.length == 3) {
            result_set_type = (Integer)args[1];
            result_set_concurrency = (Integer)args[2];
            columnIndexes = null;
            columnNames = null;
            autogeneratedKeys = null;
            resultSetHoldability = null;
        } else {
            if (args.length != 4) throw new IllegalArgumentException("Unexpected number of args to " + stmtProducingMethod.getName());
            result_set_type = (Integer)args[1];
            result_set_concurrency = (Integer)args[2];
            columnIndexes = null;
            columnNames = null;
            autogeneratedKeys = null;
            resultSetHoldability = (Integer)args[3];
        }
        spare.init(pcon, stmtText, is_callable, result_set_type, result_set_concurrency, columnIndexes, columnNames, autogeneratedKeys, resultSetHoldability);
        StatementCacheKey out = (StatementCacheKey)keyCoalescer.coalesce((Object)spare);
        if (out != spare) return out;
        spare = new ValueIdentityStatementCacheKey();
        return out;
    }

    @Override
    void init(Connection physicalConnection, String stmtText, boolean is_callable, int result_set_type, int result_set_concurrency, int[] columnIndexes, String[] columnNames, Integer autogeneratedKeys, Integer resultSetHoldability) {
        super.init(physicalConnection, stmtText, is_callable, result_set_type, result_set_concurrency, columnIndexes, columnNames, autogeneratedKeys, resultSetHoldability);
        this.cached_hash = StatementCacheKey.hashCode(this);
    }

    static {
        spare = new ValueIdentityStatementCacheKey();
        CoalesceChecker cc = new CoalesceChecker(){

            public boolean checkCoalesce(Object a, Object b) {
                return StatementCacheKey.equals((StatementCacheKey)a, b);
            }

            public int coalesceHash(Object a) {
                return ((ValueIdentityStatementCacheKey)a).cached_hash;
            }
        };
        keyCoalescer = CoalescerFactory.createCoalescer((CoalesceChecker)cc, (boolean)true, (boolean)false);
    }
}

